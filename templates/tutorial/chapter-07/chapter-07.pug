extends ../tutorial.pug

block title
  | Chapter 07: Database Integration - F4 Framework Tutorial

block content
  .chapter-header
    .chapter-number Chapter 07
    h1 Database Integration
    p.description Master F4's SQL-native query builder with powerful placeholder syntax for PostgreSQL

  .content-section
    h2 Introduction

    p F4 includes a unique query builder designed specifically for PostgreSQL. Unlike traditional query builders, F4's approach is based on three core principles:

    ul
      li <strong>Follow native SQL syntax as closely as possible</strong> - Write queries that look like SQL
      li <strong>Make minimal assumptions about literals</strong> - You control how values are interpreted
      li <strong>Provide extremely powerful placeholder syntax</strong> - Safe parameterization anywhere in the query

    .info-box
      strong Philosophy:
      |  
      | F4's query builder doesn't try to abstract SQL away. Instead, it gives you the power of SQL with built-in safety through placeholders.

  .content-section
    h2 The DB Class

    p The <code>DB</code> class is your entry point for database operations. It provides two types of methods:

    h3 Static Methods (Query Starters)

    p These methods create a new query:

    table
      thead
        tr
          th Method
          th Purpose
      tbody
        tr
          td
            code DB::select()
          td Start a SELECT query
        tr
          td
            code DB::selectDistinct()
          td Start a SELECT DISTINCT query
        tr
          td
            code DB::insert()
          td Start an INSERT query
        tr
          td
            code DB::update()
          td Start an UPDATE query
        tr
          td
            code DB::delete()
          td Start a DELETE query
        tr
          td
            code DB::with()
          td Start a query with CTE (Common Table Expression)
        tr
          td
            code DB::withRecursive()
          td Start a recursive CTE query
        tr
          td
            code DB::raw()
          td Execute raw SQL
        tr
          td
            code DB::dropTable()
          td Drop a table
        tr
          td
            code DB::dropTableIfExists()
          td Drop table if it exists
        tr
          td
            code DB::dropTableWithCascade()
          td Drop table with CASCADE
        tr
          td
            code DB::dropTableIfExistsWithCascade()
          td Drop table if exists with CASCADE

    h3 Instance Methods (Query Builders)

    p These methods build upon an existing query:

    .demo-box
      h4 Filtering and Conditions

      ul
        li <code>where()</code> - Add WHERE clause
        li <code>having()</code> - Add HAVING clause

      h4 Joins

      ul
        li <code>join()</code>, <code>innerJoin()</code> - INNER JOIN
        li <code>leftJoin()</code>, <code>leftOuterJoin()</code> - LEFT JOIN
        li <code>rightJoin()</code>, <code>rightOuterJoin()</code> - RIGHT JOIN
        li <code>fullOuterJoin()</code> - FULL OUTER JOIN
        li <code>crossJoin()</code> - CROSS JOIN
        li <code>naturalJoin()</code> - NATURAL JOIN
        li <code>joinLateral()</code>, <code>innerJoinLateral()</code> - LATERAL joins
        li <code>leftJoinLateral()</code>, <code>crossJoinLateral()</code> - Lateral variants
        li <code>on()</code> - Specify join condition

      h4 Grouping and Ordering

      ul
        li <code>group()</code>, <code>groupBy()</code> - GROUP BY
        li <code>groupByAll()</code> - GROUP BY ALL
        li <code>groupByDistinct()</code> - GROUP BY DISTINCT
        li <code>order()</code>, <code>orderBy()</code> - ORDER BY

      h4 Limiting and Pagination

      ul
        li <code>limit()</code> - LIMIT rows
        li <code>offset()</code> - OFFSET rows

      h4 Set Operations

      ul
        li <code>union()</code> - UNION
        li <code>unionAll()</code> - UNION ALL
        li <code>except()</code> - EXCEPT
        li <code>exceptAll()</code> - EXCEPT ALL
        li <code>intersect()</code> - INTERSECT
        li <code>intersectAll()</code> - INTERSECT ALL

      h4 INSERT/UPDATE Specific

      ul
        li <code>into()</code> - Specify target table
        li <code>values()</code> - Provide values for INSERT
        li <code>set()</code> - SET clause for UPDATE
        li <code>onConflict()</code> - ON CONFLICT clause
        li <code>doNothing()</code> - DO NOTHING
        li <code>doUpdateSet()</code> - DO UPDATE SET
        li <code>returning()</code> - RETURNING clause

      h4 Other

      ul
        li <code>from()</code> - FROM clause
        li <code>using()</code> - USING clause
        li <code>with()</code>, <code>withRecursive()</code> - CTEs

  .content-section
    h2 The Power of Placeholders

    p F4's query builder uses a powerful placeholder system that allows safe parameterization anywhere in your SQL. There are three types of placeholders:

    h3 1. Single Value Placeholder: {#}

    p Substitutes a single scalar value (string, number, boolean, null):

    pre
      code.language-php.
        // Simple where clause
        DB::select()
            ->from('users')
            ->where(['"id" = {#}' => 123])
            ->asRow();

        // Generates: SELECT * FROM "users" WHERE "id" = $1
        // Parameters: [123]

    pre
      code.language-php.
        // Multiple conditions
        DB::select()
            ->from('posts')
            ->where([
                '"user_id" = {#}' => 5,
                '"status" = {#}' => 'published',
                '"created_at" > {#}' => '2024-01-01'
            ])
            ->asTable();

        // WHERE "user_id" = $1 AND "status" = $2 AND "created_at" > $3

    h3 2. Array Value Placeholder: {#,...#}

    p Substitutes an array of values, perfect for IN clauses:

    pre
      code.language-php.
        // IN clause with multiple values
        $ids = [1, 2, 3, 5, 8];

        DB::select()
            ->from('products')
            ->where(['"id" IN ({#,...#})' => $ids])
            ->asTable();

        // WHERE "id" IN ($1, $2, $3, $4, $5)
        // Parameters: [1, 2, 3, 5, 8]

    pre
      code.language-php.
        // Multiple array placeholders
        $categories = ['electronics', 'computers'];
        $statuses = ['active', 'featured'];

        DB::select()
            ->from('products')
            ->where([
                '"category" IN ({#,...#})' => $categories,
                '"status" IN ({#,...#})' => $statuses
            ])
            ->asTable();

    h3 3. Subquery Placeholder: {#::#}

    p Substitutes another DB query object as a subquery:

    pre
      code.language-php.
        // Subquery in WHERE clause
        $avgPriceQuery = DB::select('AVG(price)')
            ->from('products');

        DB::select()
            ->from('products')
            ->where(['"price" > ({#::#})' => $avgPriceQuery])
            ->asTable();

    pre
      code.language-php.
        // Subquery in FROM clause
        $recentPosts = DB::select()
            ->from('posts')
            ->where(['"created_at" > {#}' => '2024-01-01']);

        DB::select()
            ->from(['({#::#}) AS "recent"' => $recentPosts])
            ->asTable();

        // SELECT * FROM (SELECT * FROM "posts" WHERE "created_at" > $1) AS "recent"

    .info-box
      strong Powerful Feature:
      | Placeholders can be used <strong>anywhere</strong> a string is accepted, not just in specific methods. This makes F4's query builder incredibly flexible.

  .content-section
    h2 Basic SELECT Queries

    h3 Simple SELECT

    pre
      code.language-php.
        // Select all columns from a table
        $users = DB::select()
            ->from('user')
            ->asTable();

        // SELECT * FROM "user"

    pre
      code.language-php.
        // Select specific columns
        $users = DB::select(['id', 'username', 'email'])
            ->from('user')
            ->asTable();

        // SELECT "id", "username", "email" FROM "user"

    pre
      code.language-php.
        // Select with aliases
        $data = DB::select(['"u"."id"', '"u"."username"', '"p"."title" AS "post_title"'])
            ->from('user u')
            ->join('post p')
            ->on(['"u"."id" = "p"."user_id"'])
            ->asTable();

    h3 WHERE Clauses

    pre
      code.language-php.
        // Simple equality using shorthand (auto-quoted)
        DB::select()
            ->from('user')
            ->where([
                'age' => 18,
                'status' => 'active'
            ])
            ->asTable();

        // WHERE "age" = $1 AND "status" = $2

    pre
      code.language-php.
        // Custom expressions with placeholders
        DB::select()
            ->from('user')
            ->where([
                '"age" >= {#}' => 18,
                'status' => 'active'
            ])
            ->asTable();

        // WHERE "age" >= $1 AND "status" = $2

    pre
      code.language-php.
        // Complex conditions with LIKE, NULL checks
        DB::select()
            ->from('article')
            ->where([
                '"title" LIKE {#}' => '%tutorial%',
                '"views" >= {#}' => 100,
                'published_at' => null  // IS NULL
            ])
            ->asTable();

  .content-section
    h2 JOINS

    p F4 supports all PostgreSQL join types with natural SQL syntax:

    pre
      code.language-php.
        // INNER JOIN
        DB::select(['"u".*', '"p"."title"'])
            ->from('user u')
            ->innerJoin('post p')
            ->on(['"u"."id" = "p"."user_id"'])
            ->asTable();

    pre
      code.language-php.
        // LEFT JOIN with conditions
        DB::select()
            ->from('user u')
            ->leftJoin('order o')
            ->on([
                '"u"."id" = "o"."user_id"',
                '"o"."status"' => 'completed'
            ])
            ->asTable();

    pre
      code.language-php.
        // USING clause for natural joins
        DB::select()
            ->from('user u')
            ->join('profile p')
            ->using('user_id')
            ->asTable();

  .content-section
    h2 GROUP BY and Aggregates

    pre
      code.language-php.
        // Simple GROUP BY
        DB::select(['category', 'COUNT(*) AS "count"'])
            ->from('product')
            ->groupBy('category')
            ->asTable();

    pre
      code.language-php.
        // GROUP BY with HAVING
        DB::select(['user_id', 'COUNT(*) AS "order_count"'])
            ->from('order')
            ->groupBy('user_id')
            ->having(['COUNT(*) > {#}' => 5])
            ->asTable();

  .content-section
    h2 ORDER BY, LIMIT, and OFFSET

    pre
      code.language-php.
        // Ordering results
        DB::select()
            ->from('post')
            ->orderBy('"created_at" DESC', 'title ASC')
            ->asTable();

    pre
      code.language-php.
        // Pagination
        $page = 2;
        $perPage = 20;

        DB::select()
            ->from('user')
            ->orderBy('username')
            ->limit($perPage)
            ->offset(($page - 1) * $perPage)
            ->asTable();

  .content-section
    h2 INSERT Queries

    pre
      code.language-php.
        use F4\DB\Fragment;

        // Simple INSERT
        DB::insert()
            ->into('user')
            ->values([
                'username' => 'john_doe',
                'email' => 'john@example.com',
                'age' => 25,
                'created_at' => new Fragment('NOW()')
            ])
            ->commit();

    .warning-box
      strong Important - Fragment Required for SQL Functions:
      |
      | Due to PostgreSQL syntax limitations, you MUST use the <code>Fragment</code> wrapper to include SQL expressions (like <code>NOW()</code>) in <code>values()</code>. Unlike <code>set()</code> where you can use string expressions like <code>'"column" = NOW()'</code>, the <code>values()</code> method requires: <code>'column' => new Fragment('NOW()')</code>.

    pre
      code.language-php.
        // INSERT with RETURNING
        $newUserId = DB::insert()
            ->into('user')
            ->values([
                'username' => 'jane_doe',
                'email' => 'jane@example.com'
            ])
            ->returning('id')
            ->asValue();

    pre
      code.language-php.
        // INSERT with ON CONFLICT (upsert)
        DB::insert()
            ->into('settings')
            ->values(['key' => 'theme', 'value' => 'dark'])
            ->onConflict('key')
            ->doUpdateSet(['value' => 'dark', '"updated_at" = NOW()'])
            ->commit();

    .info-box
      strong Notice:
      |
      | In <code>doUpdateSet()</code>, you CAN use string expressions like <code>'"updated_at" = NOW()'</code> directly (same as <code>set()</code>), but in <code>values()</code> you must use <code>Fragment</code>.

  .content-section
    h2 UPDATE Queries

    pre
      code.language-php.
        // Simple UPDATE
        DB::update('user')
            ->set([
                'status' => 'inactive',
                '"updated_at" = NOW()'
            ])
            ->where(['"last_login"  => '2023-01-01'])
            ->commit();

    pre
      code.language-php.
        // UPDATE with RETURNING
        $updated = DB::update('product')
            ->set(['price' => 29.99])
            ->where(['"id" = {#}' => 100])
            ->returning('*')
            ->asRow();

  .content-section
    h2 DELETE Queries

    pre
      code.language-php.
        // Simple DELETE
        DB::delete()
            ->from('session')
            ->where(['"expires_at" ])
            ->commit();

    pre
      code.language-php.
        // DELETE with RETURNING
        $deletedIds = DB::delete()
            ->from('old_record')
            ->where(['"created_at"  => '2020-01-01'])
            ->returning('id')
            ->asTable();

  .content-section
    h2 Common Table Expressions (CTEs)

    pre
      code.language-php.
        // WITH clause (CTE)
        $recentOrders = DB::select()
            ->from('order')
            ->where(['"created_at" > {#}' => '2024-01-01']);

        DB::with(['recent_order' => $recentOrders])
            ->select(['user_id', 'COUNT(*) AS "order_count"'])
            ->from('recent_order')
            ->groupBy('user_id')
            ->asTable();

  .content-section
    h2 Executing Queries

    p F4 provides several methods to execute and retrieve results:

    table
      thead
        tr
          th Method
          th Returns
          th Use Case
      tbody
        tr
          td
            code ->asRow()
          td Single row (array) or null
          td Fetch one record
        tr
          td
            code ->asTable()
          td Array of rows
          td Fetch multiple records
        tr
          td
            code ->commit()
          td Array of rows (same as asTable)
          td Execute INSERT/UPDATE/DELETE
        tr
          td
            code ->asValue()
          td Single scalar value
          td Get a single column value (COUNT, MAX, etc.)

    pre
      code.language-php.
        // Fetch one record
        $user = DB::select()
            ->from('user')
            ->where(['id' => 1])
            ->asRow();

        // Fetch all records
        $users = DB::select()->from('user')->asTable();

        // Get scalar value
        $count = DB::select('COUNT(*)')->from('user')->asValue();

        // Execute INSERT/UPDATE/DELETE
        DB::delete()->from('user')->where(['active' => false])->commit();

  .content-section
    h2 Raw SQL

    p When you need full control, use raw SQL with placeholders:

    pre
      code.language-php.
        // Raw query with placeholders
        $results = DB::raw(
            'SELECT * FROM "user" WHERE "age" > {#} AND "city" = {#}',
            [18, 'New York']
        )->asTable();

  .content-section
    h2 Best Practices

    ol
      li <strong>Always use placeholders</strong> - Never concatenate user input into SQL strings
      li <strong>Write SQL naturally</strong> - F4 doesn't force abstraction; write readable SQL
      li <strong>Use appropriate placeholder types</strong> - {#} for values, {#,...#} for arrays, {#::#} for subqueries
      li <strong>Leverage PostgreSQL features</strong> - CTEs, LATERAL joins, RETURNING clauses
      li <strong>Use RETURNING</strong> - Get inserted/updated data without extra queries
      li <strong>Handle null correctly</strong> - Use IS NULL/IS NOT NULL in conditions
      li <strong>Index your queries</strong> - Monitor with DEBUG_DB_QUERIES and add appropriate indexes

  .content-section
    h2 Try It Yourself

    p Practice exercises:

    ol
      li Write a query to find users who have made more than 5 orders
      li Create an INSERT with ON CONFLICT to handle duplicate emails
      li Build a query with a CTE to calculate running totals
      li Use a subquery placeholder to find products above average price
      li Write an UPDATE that uses a RETURNING clause

  .content-section
    h2 Key Takeaways

    ul
      li F4's query builder follows native SQL syntax closely
      li Three placeholder types: {#}, {#,...#}, {#::#} for maximum flexibility
      li Placeholders work <strong>anywhere</strong> in query strings, not just specific methods
      li Associative array shorthand auto-quotes identifiers: <code>['name' => 'John']</code> â†’ <code>"name" = $1</code>
      li Custom expressions need manual quoting: <code>['"age" > {#}' => 18]</code>
      li Full PostgreSQL support including CTEs, LATERAL joins, and RETURNING
      li Methods are chainable for building complex queries step by step
      li Execution methods: <code>asRow()</code>, <code>asTable()</code>, <code>commit()</code>, <code>asValue()</code>
      li Use <code>Fragment</code> class to inject SQL expressions like NOW() without binding
      li The query builder makes minimal assumptions - you're in control

  .content-section
    h2 What's Next?

    p In Chapter 8, we'll explore internationalization (i18n) and learn how to build multilingual applications with F4's Fluent-based translation system!
