extends ../tutorial.pug

block title
  | Chapter 4: Parameter Validation - F4 Framework Tutorial

block content
  .chapter-header
    .chapter-number Chapter 4
    h1 Parameter Validation
    p.description Learn to validate and sanitize input using PHP attributes

  .content-section
    h2 Introduction

    p In Chapter 2, you learned about path parameters with type constraints. Now we'll explore F4's powerful attribute-based validation system that lets you validate query parameters, form data, and more.

    h3 What We'll Cover

    ul
      li Validation attributes for parameters
      li Sanitization and filtering
      li Constraints (min, max, length)
      li Complex validators (ArrayKeys for nested data)
      li Default values and optional parameters
      li Handling validation errors
      li Combining multiple validators

  .content-section
    h2 Why Use Attributes?

    p F4 uses PHP 8+ attributes to define validation rules directly on function parameters. This provides:

    ul
      li Type-safe validation
      li Self-documenting code
      li Automatic error handling
      li Built-in sanitization
      li Composable validators

    .info-box
      strong Key Concept:
      |  
      | Attributes are evaluated before your handler function runs. Invalid data throws a <code>ValidationFailedException</code>.

  .content-section
    h2 Basic Validation Attributes

    .warning-box
      strong Important - Is* vs Cast* Validators:
      |
      | Validators prefixed with <code>Is*</code> (like <code>IsInt</code>, <code>IsEmail</code>, <code>IsBool</code>) will throw a <code>ValidationFailedException</code> if the input data does not match the expected type or format. To avoid exceptions and instead transform the data to the correct type, use <code>Cast*</code> validators (like <code>CastInt</code>, <code>CastBool</code>, <code>CastFloat</code>) which coerce the input value rather than validate it.

    h3 IsNotEmpty

    p Ensures a parameter has a value:

    pre
      code.language-php.
        use F4\Core\Validator\IsNotEmpty;

        Route::post('/submit', function(
            \#[IsNotEmpty]
            string $name
        ) {
            return ['name' => $name];
        });

    h3 IsEmail

    p Validates email addresses:

    pre
      code.language-php.
        use F4\Core\Validator\IsEmail;

        Route::post('/register', function(
            \#[IsEmail]
            string $email
        ) {
            return ['email' => $email];
        });

    h3 IsInt, IsFloat, IsBool

    p Type validation for query parameters - strict validation that throws exceptions:

    pre
      code.language-php.
        use F4\Core\Validator\{IsInt, Min, Max};

        // Using IsInt - will throw exception if $page is not an integer
        Route::get('/products', function(
            \#[IsInt]
            \#[Min(1)]
            \#[Max(100)]
            int $page = 1
        ) {
            return ['page' => $page];
        });

    h3 CastInt, CastFloat, CastBool (Recommended)

    p Type coercion - transforms input to the correct type without throwing exceptions:

    pre
      code.language-php.
        use F4\Core\Validator\{CastInt, Min, Max};

        // Using CastInt - converts string "42" to integer 42
        Route::get('/products', function(
            \#[CastInt]
            \#[Min(1)]
            \#[Max(100)]
            int $page = 1
        ) {
            return ['page' => $page];
        });

    .info-box
      strong Best Practice:
      |
      | Use <code>Cast*</code> validators for query parameters and form data (which arrive as strings). Use <code>Is*</code> validators only when you need strict type checking and want validation to fail on type mismatches.

  .content-section
    h2 Sanitization Attributes

    p Sanitization attributes clean and normalize input before validation:

    h3 Trim

    p Removes whitespace from both ends:

    pre
      code.language-php.
        use F4\Core\Validator\Trim;

        \#[Trim]
        string $username
        // "  john  " becomes "john"

    h3 SanitizedString

    p Removes HTML tags and special characters:

    pre
      code.language-php.
        use F4\Core\Validator\SanitizedString;

        \#[SanitizedString]
        string $comment
        // Strips potentially dangerous HTML/JS

    h3 CastInt

    p Converts string to integer:

    pre
      code.language-php.
        use F4\Core\Validator\CastInt;

        \#[CastInt]
        int $quantity
        // "42" becomes 42

  .content-section
    h2 Constraint Attributes

    h3 Min and Max

    table
      thead
        tr
          th Attribute
          th Use Case
          th Example
      tbody
        tr
          td
            code \#[Min(18)]
          td Minimum age
          td Age must be ≥ 18
        tr
          td
            code \#[Max(100)]
          td Maximum quantity
          td Quantity must be ≤ 100
        tr
          td
            code \#[Min(1)] \#[Max(5)]
          td Rating system
          td Rating between 1-5

    h3 IsGreaterThan and IsLessThan

    pre
      code.language-php.
        use F4\Core\Validator\{IsGreaterThan, IsLessThan};

        \#[IsGreaterThan(0)]
        \#[IsLessThan(1000)]
        float $price

  .content-section
    h2 String Validators

    h3 IsUrl

    pre
      code.language-php.
        use F4\Core\Validator\IsUrl;

        \#[IsUrl]
        string $website
        // Validates URL format

    h3 IsUuid

    pre
      code.language-php.
        use F4\Core\Validator\IsUuid;

        \#[IsUuid]
        string $id
        // Validates UUID format

    h3 RegExp

    pre
      code.language-php.
        use F4\Core\Validator\RegExp;

        \#[RegExp('/^[A-Z]{3}-[0-9]{4}$/')]
        string $productCode
        // Matches: ABC-1234

  .content-section
    h2 Complex Validators

    p F4 provides powerful validators for complex data structures like arrays with specific keys and nested validation.

    h3 OneOf / IsOneOf

    p Restrict values to a specific set:

    pre
      code.language-php.
        use F4\Core\Validator\IsOneOf;

        \#[IsOneOf(['draft', 'published', 'archived'])]
        string $status
        // Only accepts: draft, published, or archived

    h3 ArrayOf

    p Validate arrays where all elements must pass the same validation:

    pre
      code.language-php.
        use F4\Core\Validator\ArrayOf;
        use F4\Core\Validator\CastInt;

        \#[ArrayOf(new CastInt())]
        array $ids
        // Ensures $ids is an array of integers

    h3 ArrayKeys - Validating Complex Arrays

    p The <code>ArrayKeys</code> validator allows you to validate associative arrays with specific keys, where each key can have its own validation rules:

    pre
      code.language-php.
        use F4\Core\Validator\{ArrayKeys, SanitizedString, CastInt, Min, Max};

        Route::get('/employees', function(
            \#[ArrayKeys([
                'search' => new SanitizedString,
                'employeeID' => new SanitizedString
            ])]
            array $filter = [],
            \#[CastInt, Min(0)]
            int $offset = 0,
            \#[CastInt, Min(1), Max(100)]
            int $limit = 20
        ) {
            // $filter is validated as associative array
            // - 'search' key: sanitized string
            // - 'employeeUUID' key: sanitized string
            // $offset: must be integer >= 0
            // $limit: must be integer between 1 and 100

            return [
                'filter' => $filter,
                'offset' => $offset,
                'limit' => $limit
            ];
        });

    p Example usage:

    .demo-box
      pre
        code.language-php.
          // Query: /employees?filter[search]=john&filter[employeeUUID]=abc-123&offset=10&limit=50

          // Validated data:
          $filter = [
              'search' => 'john',          // Sanitized string
              'employeeUUID' => 'abc-123'   // Sanitized string
          ];
          $offset = 10;                    // Cast to int, validated >= 0
          $limit = 50;                     // Cast to int, validated 1-100

    h3 Nested ArrayKeys Example

    p You can also nest <code>ArrayKeys</code> validators for deeply nested structures:

    pre
      code.language-php.
        use F4\Core\Validator\{ArrayKeys, SanitizedString, IsEmail, IsOneOf};

        \#[ArrayKeys([
            'name' => new SanitizedString,
            'email' => new IsEmail,
            'role' => new IsOneOf(['admin', 'user', 'guest']),
            'preferences' => new ArrayKeys([
                'theme' => new IsOneOf(['light', 'dark']),
                'notifications' => new IsOneOf(['enabled', 'disabled'])
            ])
        ])]
        array $userData

    .info-box
      strong Key Benefits:
      |
      | <code>ArrayKeys</code> ensures type safety for complex request data, validates each field independently, and provides clear error messages when validation fails.

  .content-section
    h2 Default Values

    h3 DefaultValue

    p Provides a fallback when parameter is missing:

    pre
      code.language-php.
        use F4\Core\Validator\DefaultValue;

        Route::get('/search', function(
            string $query,
            \#[DefaultValue(10)]
            int $limit = 10
        ) {
            return ['query' => $query, 'limit' => $limit];
        });

    h3 NullIfEmpty

    pre
      code.language-php.
        use F4\Core\Validator\NullIfEmpty;

        \#[NullIfEmpty]
        ?string $middleName
        // Empty string becomes null

  .content-section
    h2 Combining Validators

    p Stack multiple attributes for comprehensive validation:

    pre
      code.language-php.
        use F4\Core\Validator\{
            IsNotEmpty,
            Trim,
            SanitizedString,
            IsEmail
        };

        Route::post('/register', function(
            \#[IsNotEmpty]
            \#[Trim]
            \#[SanitizedString]
            string $name,

            \#[IsNotEmpty]
            \#[Trim]
            \#[IsEmail]
            string $email,

            \#[IsInt]
            \#[Min(18)]
            \#[Max(120)]
            int $age
        ) {
            return [
                'name' => $name,
                'email' => $email,
                'age' => $age
            ];
        });

    .info-box
      strong Processing Order:
      | Validators are executed from top to bottom.

  .content-section
    h2 Validation Errors

    p When validation fails, F4 throws a <code>ValidationFailedException</code>:

    pre
      code.language-php.
        use F4\Core\Validator\ValidationFailedException;

        $f4->on(ValidationFailedException::class,
            function($exception, $request, $response) {
                return $response
                    ->setData(['errors' => $exception->getErrors()])
                    ->withStatus(400);
            }
        );

    p The exception contains:
    ul
      li Parameter name that failed
      li Validation rule that was violated
      li User-friendly error message

  .content-section
    h2 Complete Example: User Registration

    pre
      code.language-php.
        use F4\Core\Route;
        use F4\Core\Validator\{
            IsNotEmpty,
            Trim,
            SanitizedString,
            IsEmail,
            IsInt,
            Min,
            Max,
            DefaultValue,
            IsOneOf
        };

        Route::post('/api/users', function(
            \#[IsNotEmpty]
            \#[Trim]
            \#[SanitizedString]
            string $username,

            \#[IsNotEmpty]
            \#[Trim]
            \#[IsEmail]
            string $email,

            \#[IsInt]
            \#[Min(18)]
            \#[Max(120)]
            int $age,

            \#[DefaultValue('user')]
            \#[IsOneOf(['user', 'admin', 'moderator'])]
            string $role = 'user'
        ) {
            // All parameters are validated and sanitized
            // Safe to use directly
            return [
                'username' => $username,
                'email' => $email,
                'age' => $age,
                'role' => $role
            ];
        });

  .content-section
    h2 Validator Reference Table

    table
      thead
        tr
          th Category
          th Validators
          th Purpose
      tbody
        tr
          td Type Validation (Strict)
          td
            code IsInt, IsFloat, IsBool, IsEmail, IsUrl, IsUuid
          td Validate types (throws on mismatch)
        tr
          td Type Coercion (Flexible)
          td
            code CastInt, CastFloat, CastBool
          td Convert types (no exceptions)
        tr
          td Constraints
          td
            code Min, Max, IsGreaterThan, IsLessThan
          td Numeric boundaries
        tr
          td Sanitization
          td
            code Trim, SanitizedString, CastInt
          td Clean input
        tr
          td Presence
          td
            code IsNotEmpty, NullIfEmpty
          td Required fields
        tr
          td Patterns
          td
            code RegExp
          td Custom patterns
        tr
          td Complex Types
          td
            code IsOneOf, ArrayOf, ArrayKeys
          td Complex data structures
        tr
          td Defaults
          td
            code DefaultValue
          td Fallback values

  .content-section
    h2 Best Practices

    ol
      li <strong>Prefer <code>Cast*</code> over <code>Is*</code> validators</strong> for query parameters and form data to avoid exceptions on type mismatches
      li Always sanitize user input (use <code>Trim</code>, <code>SanitizedString</code>)
      li Validate before using in queries or logic
      li Provide sensible default values for optional parameters
      li Use specific validators (<code>IsEmail</code>) over generic ones (<code>RegExp</code>)
      li Handle <code>ValidationFailedException</code> globally with exception handlers
      li Combine validators for defense in depth (e.g., <code>CastInt</code> + <code>Min</code> + <code>Max</code>)
      li Document expected formats with validators

    .success-box
      strong Security Note:
      | Validation attributes are your first line of defense against malicious input. Always validate!

  .content-section
    h2 Try It Yourself

    p Practice exercises:

    ol
      li Create a route that validates a user profile update with name, email, and age
      li Add a search route with optional filters (category, min price, max price)
      li Implement a contact form with validation for name, email, subject, and message
      li Build an API endpoint that accepts pagination parameters (page, limit)

  .content-section
    h2 Key Takeaways

    ul
      li PHP attributes provide declarative validation
      li Validators run automatically before your handler
      li Sanitizers clean data, validators check constraints
      li Multiple validators can be stacked
      li <code>ValidationFailedException</code> is thrown on failure
      li Default values work with <code>\#[DefaultValue]</code>
      li Type safety is enforced through PHP type hints + validators
      li <code>ArrayKeys</code> enables validation of complex associative arrays with per-key validators
      li Complex validators can be nested for deeply structured data

  .content-section
    h2 What's Next?

    p In Chapter 5, we'll explore middleware:

    ul
      li Request middleware for preprocessing
      li Response middleware for postprocessing
      li Authentication and authorization patterns
      li Logging and timing middleware
      li Middleware execution order

    p Ready to learn middleware? Click "Next" below!
