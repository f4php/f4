extends ../tutorial.pug

block title
  | Chapter 5: Middleware - F4 Framework Tutorial

block content
  .chapter-header
    .chapter-number Chapter 5
    h1 Middleware
    p.description Master request and response processing with middleware

  .content-section
    h2 Introduction

    p Middleware provides a powerful way to filter, modify, or enhance HTTP requests and responses as they flow through your application. Think of middleware as layers that wrap around your route handlers.

    h3 What We'll Cover

    ul
      li What middleware is and why it's useful
      li Request middleware (before handlers)
      li Response middleware (after handlers)
      li Global vs route-specific middleware
      li Middleware execution order
      li Common patterns (auth, logging, CORS)

  .content-section
    h2 What Is Middleware?

    p Middleware functions run before or after your route handler executes. They can:

    ul
      li Modify the request before it reaches the handler
      li Check authentication or permissions
      li Log requests and responses
      li Add headers (CORS, security, etc.)
      li Transform response data
      li Handle cross-cutting concerns

    .info-box
      strong Key Concept:
      |  
      | Middleware creates a pipeline: Request → Before Middleware → Handler → After Middleware → Response

  .content-section
    h2 Request Middleware (Before)

    p Request middleware runs <strong>before</strong> your route handler. Use it to preprocess requests or enforce requirements.

    h3 Global Before Middleware

    pre
      code.language-php.
        // Runs before ALL routes
        $f4->before(function($request, $response, $route) {
            // Log every request
            error_log("Request: " . $request->getPath());

            // Must return the request
            return $request;
        });

    h3 Route-Level Before Middleware

    pre
      code.language-php.
        $f4->addRoute(Route::get('/admin', function() {
            return ['admin' => true];
        })
        ->before(function($request, $response, $route) {
            // Check if user is admin
            if (!$_SESSION['is_admin']) {
                throw new HttpException('Unauthorized', 403);
            }
            return $request;
        }));

    .info-box
      strong Important:
      |   
      | Before middleware may return the request object. You can return a modified request to change how the route handler sees the data.

  .content-section
    h2 Response Middleware (After)

    p Response middleware runs <strong>after</strong> your route handler. Use it to postprocess responses or add headers.

    h3 Global After Middleware

    pre
      code.language-php.
        // Runs after ALL routes
        $f4->after(function($response, $request, $route) {
            // Add custom header to all responses
            return $response->withHeader('X-Powered-By', 'F4');
        });

    h3 Route-Level After Middleware

    pre
      code.language-php.
        $f4->addRoute(Route::get('/api/data', function() {
            return ['items' => [1, 2, 3]];
        })
        ->after(function($response, $request, $route) {
            // Add metadata to response
            $data = $response->getData();
            $data['timestamp'] = time();
            return $response->setData($data);
        }));

  .content-section
    h2 Middleware Execution Order

    p Understanding the order is crucial for predictable behavior:

    .demo-box
      h4 Execution Flow

      pre.
        1. Global Before Middleware
        2. Route Group Before Middleware
        3. Route Before Middleware
        4. »» Route Handler Executes ««
        5. Route After Middleware
        6. Route Group After Middleware
        7. Global After Middleware

    p Multiple middleware at the same level run in registration order.

  .content-section
    h2 Common Middleware Patterns

    h3 Authentication Middleware

    pre
      code.language-php.
        function requireAuth($request, $response, $route) {
            if (!isset($_SESSION['user_id'])) {
                throw new HttpException('Please log in', 401);
            }
            return $request;
        }

        // Apply to protected routes
        $f4->addRoute(Route::get('/profile', function() {
            return ['user' => $_SESSION['user_id']];
        })->before('requireAuth'));

    h3 CORS Middleware

    pre
      code.language-php.
        $f4->after(function($response, $request, $route) {
            return $response
                ->withHeader('Access-Control-Allow-Origin', '*')
                ->withHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE')
                ->withHeader('Access-Control-Allow-Headers', 'Content-Type');
        });

    h3 Request Timing Middleware

    pre
      code.language-php.
        $f4->before(function($request, $response, $route) {
            $request->setAttribute('start_time', microtime(true));
            return $request;
        });

        $f4->after(function($response, $request, $route) {
            $duration = microtime(true) - $request->getAttribute('start_time');
            return $response->withHeader('X-Response-Time', $duration);
        });

    h3 Logging Middleware

    pre
      code.language-php.
        $f4->before(function($request, $response, $route) {
            error_log(sprintf(
                "[%s] %s %s",
                date('Y-m-d H:i:s'),
                $request->getMethod(),
                $request->getPath()
            ));
            return $request;
        });

  .content-section
    h2 RouteGroup Middleware

    p Route groups can have their own middleware that applies to all routes in the group:

    pre
      code.language-php.
        use F4\Core\RouteGroup;

        $apiGroup = new RouteGroup('/api')
            ->before(function($request, $response, $route) {
                // Validate API key for all /api/* routes
                $apiKey = $request->getHeader('X-API-Key');
                if (!isValidApiKey($apiKey)) {
                    throw new HttpException('Invalid API key', 403);
                }
                return $request;
            })
            ->addRoute(Route::get('/users', function() { /* ... */ }))
            ->addRoute(Route::get('/posts', function() { /* ... */ }));

        $f4->addRouteGroup($apiGroup);

  .content-section
    h2 Short-Circuiting with Exception Handlers

    p You can short-circuit the request flow by throwing exceptions from before middleware and handling them with exception handlers registered via <code>->on()</code>:

    h3 Exception Handler Registration

    pre
      code.language-php.
        use F4\Core\Exception\{HttpException, AccessForbiddenException};

        // Register exception handlers for specific exception types
        $apiGroup = new RouteGroup('/admin')
            ->on(AccessForbiddenException::class,
                function (AccessForbiddenException $e, Request $request, Response $response): Response {
                    // Handle access forbidden - return error page with exception
                    return $response
                        ->setException($e);
                }
            )
            ->on(UnauthorizedAccessException::class,
                fn (UnauthorizedAccessException $e, Request $request, Response $response): Response =>
                    // Redirect unauthorized users to login
                    $response->withRedirect('/admin/login')
            );

    h3 Throwing Exceptions in Before Middleware

    pre
      code.language-php.
        $apiGroup
            ->before(function (Request $request) {
                // Check authentication status
                if (!$AuthService->getAuthenticatedManager()) {
                    // Throw exception - will be caught by UnauthorizedAccessException handler
                    throw new UnauthorizedAccessException;
                }
            });

    h3 Complete Short-Circuit Example

    pre
      code.language-php.
        // Define allowed public paths
        $publicPaths = ['/admin/login'];

        $adminGroup = new RouteGroup('/admin')
            // Handle access forbidden (403)
            ->on(AccessForbiddenException::class,
                function ($e, $request, $response) use ($AuthService): Response {
                    return $response
                        ->setMetaData('authorizations', $AuthService->getAuthorizations())
                        ->setException($e);
                }
            )
            // Handle unauthorized access (redirect to login)
            ->on(UnauthorizedAccessException::class,
                fn ($e, $request, $response): Response =>
                    $response->withRedirect('/admin/login')
            )
            // Handle other HTTP exceptions
            ->on(HttpException::class,
                function ($e, $request, $response) use ($AuthService): Response {
                    return $response
                        ->setMetaData('authorizations', $AuthService->getAuthorizations())
                        ->setException($e);
                }
            )
            // Check authentication before every request
            ->before(function (Request $request) use ($publicPaths) {
                if (!new AuthenticationService()->getAuthenticatedManager()
                    && !in_array($request->getPath(), $publicPaths)) {
                    throw new UnauthorizedAccessException;
                }
            })
            ->addRoute(Route::get('/dashboard', function() { /* ... */ }))
            ->addRoute(Route::get('/login', function() { /* ... */ }));

        $f4->addRouteGroup($adminGroup);

    .info-box
      strong Key Concept:
      |  
      | Exception handlers registered with <code>->on()</code> catch exceptions thrown from <code>->before()</code> middleware, allowing you to control the response (redirect, error page, etc.) when authentication or authorization fails. The route handler is skipped when an exception is thrown.

    .warning-box
      strong Exception Handler Order:
      |  
      | Exception handlers are matched in the order specified in code, so more specific exception classes should be placed at the top of handlers registration.

  .content-section
    h2 Middleware Parameters

    p All middleware functions receive three parameters:

    table
      thead
        tr
          th Parameter
          th Type
          th Description
      tbody
        tr
          td
            code $request
          td Request
          td Current HTTP request (before middleware)
        tr
          td
            code $response
          td Response
          td Current HTTP response
        tr
          td
            code $route
          td Route|null
          td Matched route (null if no match)

    p For <code>after</code> middleware, the parameter order is different:

    pre
      code.language-php.
        // Before: (request, response, route)
        $f4->before(function($request, $response, $route) { });

        // After: (response, request, route)
        $f4->after(function($response, $request, $route) { });

  .content-section
    h2 Real-World Example: API Authentication

    pre
      code.language-php.
        use F4\Core\{Route, RouteGroup};
        use F4\Core\Exception\HttpException;

        // Public routes (no auth required)
        $f4->addRoute(Route::get('/', function() {
            return ['message' => 'Welcome'];
        }));

        // Protected API routes
        $apiGroup = new RouteGroup('/api/v1')
            ->before(function($request, $response, $route) {
                // Check Bearer token
                $auth = $request->getHeader('Authorization');
                if (!str_starts_with($auth, 'Bearer ')) {
                    throw new HttpException('Missing token', 401);
                }

                $token = substr($auth, 7);
                $user = validateToken($token);

                if (!$user) {
                    throw new HttpException('Invalid token', 403);
                }

                // Attach user to request
                $request->setAttribute('user', $user);
                return $request;
            })
            ->after(function($response, $request, $route) {
                // Add CORS headers to all API responses
                return $response
                    ->withHeader('Access-Control-Allow-Origin', '*');
            })
            ->addRoute(Route::get('/profile', function($request) {
                $user = $request->getAttribute('user');
                return ['user' => $user];
            }))
            ->addRoute(Route::get('/posts', function() {
                return ['posts' => [/* ... */]];
            }));

        $f4->addRouteGroup($apiGroup);

  .content-section
    h2 Best Practices

    ol
      li Keep middleware functions focused and single-purpose
      li Use global middleware sparingly (performance impact)
      li Prefer route-group middleware for API authentication
      li Always return the request/response object
      li Document what each middleware does
      li Use attributes on requests to pass data between middleware
      li Handle errors with exceptions (use exception handlers)
      li Avoid heavy computation in middleware

  .content-section
    h2 Try It Yourself

    p Practice exercises:

    ol
      li Create logging middleware that tracks request timing
      li Build authentication middleware for protected routes
      li Add CORS headers to API endpoints
      li Implement rate limiting middleware
      li Create middleware that adds pagination metadata

  .content-section
    h2 Key Takeaways

    ul
      li Middleware wraps around route handlers
      li <code>before()</code> runs before handlers (preprocessing)
      li <code>after()</code> runs after handlers (postprocessing)
      li Execution order: Global → Group → Route → Handler → Route → Group → Global
      li Middleware can modify requests and responses
      li Route groups can share middleware
      li Short-circuit by returning a response from before middleware
      li Use middleware for cross-cutting concerns

  .content-section
    h2 What's Next?

    p In Chapter 6, we'll explore Route Groups in detail:

    ul
      li Organizing routes with groups
      li Path prefixes and nesting
      li Shared middleware and configuration
      li Building RESTful APIs
      li Versioning strategies

    p Ready to organize your routes? Click "Next" below!
